/**
 * @file Update script templates for Aether CMS installations
 * @module update-scripts
 */

import fs from "fs"
import path from "path"
import { execSync } from "child_process"

/**
 * Configuration for update scripts
 */
const CONFIG = {
    REPO_URL: "https://github.com/LebCit/aether-cms.git",
    REMOTE_NAME: "upstream",
    DEFAULT_BRANCH: "main",
    SCRIPTS_DIR: "assets/js",
    SCRIPTS: {
        CHECK_UPDATES: "check-updates.js",
        UPDATE_AETHER: "update-aether.js",
    },
}

/**
 * Create enhanced update scripts compatible with EnhancedUpdateService
 * @param {string} targetPath - The project directory
 * @param {Object} options - Configuration options
 * @param {string} options.scriptsDir - Custom scripts directory (optional)
 * @param {string} options.repoUrl - Custom repository URL (optional)
 */
export function createUpdateScripts(targetPath, options = {}) {
    const config = { ...CONFIG, ...options }
    const scriptsDir = path.join(targetPath, config.scriptsDir || CONFIG.SCRIPTS_DIR)

    // Ensure scripts directory exists
    if (!fs.existsSync(scriptsDir)) {
        fs.mkdirSync(scriptsDir, { recursive: true })
    }

    try {
        // Create check-updates script
        const checkUpdatesScript = getCheckUpdatesScript(config)
        fs.writeFileSync(path.join(scriptsDir, CONFIG.SCRIPTS.CHECK_UPDATES), checkUpdatesScript)

        // Create update script
        const updateScript = getUpdateScript(config)
        fs.writeFileSync(path.join(scriptsDir, CONFIG.SCRIPTS.UPDATE_AETHER), updateScript)

        // Make scripts executable on Unix systems
        makeScriptsExecutable(scriptsDir)

        console.log("üìú Created enhanced update scripts")
        return {
            scriptsDir,
            scripts: [
                path.join(scriptsDir, CONFIG.SCRIPTS.CHECK_UPDATES),
                path.join(scriptsDir, CONFIG.SCRIPTS.UPDATE_AETHER),
            ],
        }
    } catch (error) {
        console.error("‚ùå Failed to create update scripts:", error.message)
        throw error
    }
}

/**
 * Get the check-updates script template with configuration
 * @param {Object} config - Configuration object
 * @returns {string} Script content
 */
function getCheckUpdatesScript(config) {
    return `#!/usr/bin/env node
/**
 * Enhanced update checker for Aether CMS
 * Handles all git repository states
 * Generated by create-aether-cms
 */
import { execSync } from 'child_process'

// Configuration
const REPO_URL = '${config.repoUrl || CONFIG.REPO_URL}'
const REMOTE_NAME = '${config.remoteName || CONFIG.REMOTE_NAME}'
const DEFAULT_BRANCH = '${config.defaultBranch || CONFIG.DEFAULT_BRANCH}'

console.log('üîç Checking for Aether CMS updates...')

try {
    await ensureProperGitBranch()
    await ensureUpstreamRemote()
    await fetchUpstreamChanges()
    await compareVersions()
    
} catch (error) {
    console.error('‚ùå Failed to check for updates:', error.message)
    await diagnoseGitIssues()
    process.exit(1)
}

async function ensureProperGitBranch() {
    try {
        let currentBranch = ''
        try {
            currentBranch = execSync('git symbolic-ref --short HEAD', { encoding: 'utf8' }).trim()
        } catch {
            // We're in detached HEAD state
        }
        
        if (!currentBranch) {
            console.log('üîÑ Setting up git branch for updates...')
            try {
                execSync(\`git switch -c \${DEFAULT_BRANCH}\`, { stdio: 'ignore' })
            } catch {
                try {
                    execSync(\`git checkout -b \${DEFAULT_BRANCH}\`, { stdio: 'ignore' })
                } catch {
                    const currentCommit = execSync('git rev-parse HEAD', { encoding: 'utf8' }).trim()
                    execSync(\`git branch \${DEFAULT_BRANCH} \${currentCommit}\`, { stdio: 'ignore' })
                    execSync(\`git checkout \${DEFAULT_BRANCH}\`, { stdio: 'ignore' })
                }
            }
            console.log('‚úÖ Git branch setup complete')
        }
    } catch (branchError) {
        console.warn('‚ö†Ô∏è Branch setup issue:', branchError.message)
    }
}

async function ensureUpstreamRemote() {
    try {
        const upstreamUrl = execSync(\`git remote get-url \${REMOTE_NAME}\`, { encoding: 'utf8' }).trim()
        if (!upstreamUrl.includes(REPO_URL.replace('https://github.com/', '').replace('.git', ''))) {
            execSync(\`git remote set-url \${REMOTE_NAME} \${REPO_URL}\`, { stdio: 'ignore' })
        }
    } catch {
        execSync(\`git remote add \${REMOTE_NAME} \${REPO_URL}\`, { stdio: 'ignore' })
    }
}

async function fetchUpstreamChanges() {
    console.log('üì• Fetching latest information...')
    
    // Try multiple fetch strategies
    const fetchStrategies = [
        () => execSync(\`git fetch \${REMOTE_NAME} --unshallow\`, { stdio: 'ignore' }),
        () => execSync(\`git fetch \${REMOTE_NAME}\`, { stdio: 'ignore' }),
        () => execSync(\`git fetch \${REMOTE_NAME} \${DEFAULT_BRANCH}\`, { stdio: 'ignore' })
    ]
    
    for (const strategy of fetchStrategies) {
        try {
            strategy()
            break
        } catch (error) {
            if (strategy === fetchStrategies[fetchStrategies.length - 1]) {
                throw error
            }
        }
    }
}

async function compareVersions() {
    try {
        const currentCommit = execSync('git rev-parse HEAD', { encoding: 'utf8' }).trim()
        const latestCommit = execSync(\`git rev-parse \${REMOTE_NAME}/\${DEFAULT_BRANCH}\`, { encoding: 'utf8' }).trim()
        
        if (currentCommit !== latestCommit) {
            console.log('‚ú® Updates available!')
            console.log('üéØ Run "npm run update-aether" to update safely')
            
            await showUpdateDetails(currentCommit, latestCommit)
        } else {
            console.log('‚úÖ You are running the latest version!')
        }
    } catch (compareError) {
        console.log('üìã Could not compare versions, but updates may be available')
        console.log('üí° Try running "npm run update-aether" to check for updates')
    }
}

async function showUpdateDetails(currentCommit, latestCommit) {
    try {
        const changes = execSync(\`git log --oneline \${currentCommit}..\${latestCommit}\`, { encoding: 'utf8' })
        console.log('\\nüìã Recent changes:')
        console.log(changes)
        
        const diffStat = execSync(\`git diff --stat \${currentCommit}..\${latestCommit}\`, { encoding: 'utf8' })
        const fileCount = (diffStat.match(/\\d+ files? changed/g) || ['0 files changed'])[0]
        console.log('üìÅ Changes:', fileCount)
    } catch (logError) {
        console.log('üìã Update details available after running update command')
    }
}

async function diagnoseGitIssues() {
    console.log('üí° Make sure you are in the project directory and have git initialized')
    
    try {
        const remotes = execSync('git remote -v', { encoding: 'utf8' })
        console.log('\\nüîç Git remotes:')
        console.log(remotes)
        
        const status = execSync('git status --porcelain=v1', { encoding: 'utf8' })
        console.log('\\nüîç Git status: ' + (status.trim() || 'Clean working directory'))
        
        const branch = execSync('git branch --show-current 2>/dev/null || echo "detached"', { 
            encoding: 'utf8',
            shell: true 
        }).trim()
        console.log('üîç Current branch:', branch || 'detached HEAD')
        
    } catch {
        console.log('üí° Git may not be properly initialized')
    }
}
`
}

/**
 * Get the update script template with configuration
 * @param {Object} config - Configuration object
 * @returns {string} Script content
 */
function getUpdateScript(config) {
    return `#!/usr/bin/env node
/**
 * Enhanced Aether CMS updater
 * Uses the same strategy as EnhancedUpdateService
 * Generated by create-aether-cms
 */
import { execSync } from 'child_process'
import fs from 'fs'

// Configuration
const REMOTE_NAME = '${config.remoteName || CONFIG.REMOTE_NAME}'
const DEFAULT_BRANCH = '${config.defaultBranch || CONFIG.DEFAULT_BRANCH}'

console.log('üöÄ Starting Aether CMS update...')
console.log('üìã This will preserve your settings, content, and configurations')

const backupBranch = 'backup-' + Date.now()

try {
    await performSafetyChecks()
    await prepareForUpdate()
    await executeUpdate()
    await finalizeUpdate()
    
    console.log('\\nüéâ Update completed successfully!')
    console.log('‚úÖ Your settings and content have been preserved')
    console.log('üöÄ Restart your application to see the changes')
    
} catch (error) {
    console.error('‚ùå Update failed:', error.message)
    await recoverFromFailure()
    process.exit(1)
}

async function performSafetyChecks() {
    const requiredFiles = ['package.json', 'content']
    const missingFiles = requiredFiles.filter(file => !fs.existsSync(file))
    
    if (missingFiles.length > 0) {
        throw new Error(\`Missing required files/directories: \${missingFiles.join(', ')}\`)
    }
}

async function prepareForUpdate() {
    // Ensure we're on the right branch
    const currentBranch = execSync('git branch --show-current', { encoding: 'utf8' }).trim()
    if (currentBranch !== DEFAULT_BRANCH) {
        console.log(\`üîÑ Switching to \${DEFAULT_BRANCH} branch...\`)
        execSync(\`git checkout \${DEFAULT_BRANCH}\`, { stdio: 'ignore' })
    }

    // Stash uncommitted changes
    const status = execSync('git status --porcelain', { encoding: 'utf8' }).trim()
    if (status) {
        console.log('üì¶ Stashing uncommitted changes...')
        execSync('git stash push -m "Auto-stash before update"', { stdio: 'ignore' })
    }

    // Create backup branch
    execSync(\`git checkout -b \${backupBranch}\`, { stdio: 'ignore' })
    execSync(\`git checkout \${DEFAULT_BRANCH}\`, { stdio: 'ignore' })
    console.log('üíæ Created backup branch:', backupBranch)
}

async function executeUpdate() {
    await ensureGitAttributes()
    await configureGitMergeStrategy()
    await fetchAndMergeUpdates()
}

async function ensureGitAttributes() {
    if (!fs.existsSync('.gitattributes')) {
        const gitAttributes = \`# Aether CMS - Prevent merge conflicts
package.json merge=ours
package-lock.json merge=ours
.env merge=ours
content/data/settings.json merge=ours
.gitignore merge=ours
\`
        fs.writeFileSync('.gitattributes', gitAttributes)
        execSync('git add .gitattributes', { stdio: 'ignore' })
        execSync('git commit -m "Add gitattributes for updates"', { stdio: 'ignore' })
    }
}

async function configureGitMergeStrategy() {
    execSync('git config merge.ours.driver true', { stdio: 'ignore' })
}

async function fetchAndMergeUpdates() {
    console.log('üì• Fetching updates...')
    execSync(\`git fetch \${REMOTE_NAME}\`, { stdio: 'ignore' })
    
    console.log('üîÑ Applying updates...')
    execSync(\`git merge \${REMOTE_NAME}/\${DEFAULT_BRANCH} --no-edit\`, { stdio: 'inherit' })
}

async function finalizeUpdate() {
    // Regenerate package-lock.json
    console.log('üì¶ Updating dependencies...')
    if (fs.existsSync('package-lock.json')) {
        fs.unlinkSync('package-lock.json')
    }
    execSync('npm install', { stdio: 'inherit' })

    // Clean up backup branch
    execSync(\`git branch -D \${backupBranch}\`, { stdio: 'ignore' })
    
    // Restore stashed changes if any
    try {
        execSync('git stash pop', { stdio: 'ignore' })
        console.log('üì¶ Restored your changes')
    } catch {
        // No stash to pop
    }
}

async function recoverFromFailure() {
    console.log('üîÑ Attempting to restore from backup...')
    
    try {
        execSync('git merge --abort', { stdio: 'ignore' })
        execSync(\`git reset --hard \${backupBranch}\`, { stdio: 'ignore' })
        execSync(\`git branch -D \${backupBranch}\`, { stdio: 'ignore' })
        console.log('‚úÖ Restored from backup - your project is safe')
    } catch (restoreError) {
        console.error('‚ùå Could not restore automatically')
        console.log('üí° Run: git branch -a to see available branches and restore manually')
    }
}
`
}

/**
 * Make scripts executable on Unix systems
 * @param {string} scriptsDir - Scripts directory path
 */
function makeScriptsExecutable(scriptsDir) {
    const scripts = Object.values(CONFIG.SCRIPTS)

    scripts.forEach((script) => {
        try {
            execSync(`chmod +x ${path.join(scriptsDir, script)}`, { stdio: "ignore" })
        } catch (error) {
            // Ignore on Windows or if chmod fails
        }
    })
}

/**
 * Validate that generated scripts are syntactically correct
 * @param {string} targetPath - The project directory
 * @returns {boolean} Whether scripts are valid
 */
export function validateGeneratedScripts(targetPath) {
    const scriptsDir = path.join(targetPath, CONFIG.SCRIPTS_DIR)

    try {
        Object.values(CONFIG.SCRIPTS).forEach((script) => {
            const scriptPath = path.join(scriptsDir, script)
            if (!fs.existsSync(scriptPath)) {
                throw new Error(`Script not found: ${script}`)
            }

            // Basic syntax check
            execSync(`node --check ${scriptPath}`, { stdio: "ignore" })
        })

        return true
    } catch (error) {
        console.error("‚ùå Script validation failed:", error.message)
        return false
    }
}
